# 导出C API

C API 由一组函数和全局变量定义，通常从二进制导出。C 函数可以定义任意多的参数以及一个返回值。因此每个函数都由函数名和一组描述函数参数以及返回值的C类型唯一标识。API导出的全局变量同样通过名称和类型进行标识。

因此C API仅由一组名称定义，这些名称与一组类型相关联。如果您知道函数调用约定和将C类型映射到您所在机器类型，则可以解析每个函数的名称以查找与该函数有关联的代码在内存中的位置，然后为函数构建有效的参数列表。最后只需要使用参数列表触发对目标C函数的调用。

例如:
```c
static void function_foo (int foo)
{
}

int main (int argc, char* argv[])
{
    function_foo (10);

    return 0;
}
```

```asm
push   $0xa
call   0x80482f4 <function_foo>
```

上述汇编代码很简单：第一条指令将变量10压入栈中，然后调用函数function_foo。

接下来，假设我们通过Python程序调用C函数function_foo，Python解析器需要如下实现：
- 查找被调用C函数的位置。这意味着要从C编译器生成的二进制文件中查找出来。
- 在可执行内存中加载此函数的代码
- 在函数调用前，将Python参数转换为兼容C的参数类型
- 使用正确的调用约定调用函数
- 将C函数的返回值转为兼容Python的参数类型

上边描述比较复杂，但是拥有很多方法使此过程自动、透明完成。
- 第一种方案是手动编写大量胶水代码，为每个函数导入或导出一次，进行Python到C的参数转换和C到Python返回值转换。然后，这个胶水代码与解释器相关联，允许Python程序调用Python函数，将工作委托给C函数
- 另一种更好的方案是自动生成胶水代码，每个函数导入或导出以此，使用读取原始函数签名的特殊编译器。

GLib使用的解决方案是GType库，该库在运行时包含对程序员操作的所有对象的描述。这种所谓的动态类型库然后通过特殊的通用胶水代码来自动转换不同运行时域之间的函数参数和函数调用约定。

GType实现的解决方案的最大优点是，位于运行时域边界的胶水代码被写入一次：下图更清楚的说明了这一点：
![](img/glue.png)

目前，存在多种通用胶水代码，可以直接使用GType类型编写的各种语言的C对象，工作量极小，不用自动或手动生成大量胶水代码。

> GType/GObject类型不仅为C提供了面向对象功能，同时提供了透明的跨语言操作特性。



