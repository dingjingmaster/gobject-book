# 信号

信号系统的基本概念是信号的发射。信号是按类型引入的，并通过字符串进行标识。为父类型引入的信号也可以在派生类型中使用，因此基本上它们是继承的每个类型的工具。

## 信号处理函数（Handlers）

信号发射主要涉及以精确定义的方式调用一组回调函数。这类回调主要有两类：针对对象的回调和用户提供的回调。（尽管信号可以处理任何类型的可实例化类型，但这些类型在下文中被称为“对象类型”，只是因为这是大多数用户将遇到信号的上下文中。）每个对象的回调通常被称为“对象方法处理程序”或“默认（信号）处理程序”，而用户提供的回调通常被称为“信号处理程序”。

对象方法处理程序在信号创建时提供（这通常发生在对象类创建的末尾），而用户提供的处理程序经常与特定对象实例上的特定信号连接或断开连接。

处理程序必须在其参数和返回值（通常为空）中匹配信号定义的类型。所有处理程序都以指向类型实例的指针作为第一个参数，并以gpointer user_data作为最后一个参数，中间带有信号定义的参数。user_data总是填充处理程序连接到信号时提供的用户数据。处理程序在文档中被描述为具有GCallback类型，但这只是一个通用的占位符类型——GSignal api的多态工件。

当连接信号处理程序时，如果使用`g_signal_connect_swap()`而不是`g_signal_connect()`，则可以交换其第一个（‘instance‘）和最后一个（’user data’）参数。这有时可以方便地避免将包装器函数定义为信号处理程序，而是直接传递一个将用户数据作为其第一个参数的函数。

## 信号发射

信号发射包括五个阶段，除非提前停止：
1. 调用G_SIGNAL_RUN_FIRST信号的对象方法处理程序
2. 调用普通用户提供的信号处理程序（其中after标志未设置）
3. 调用G_SIGNAL_RUN_LAST信号的对象方法处理程序
4. 调用用户提供的信号处理程序（其中设置了after标志）
5. 为G_SIGNAL_RUN_CLEANUP信号调用对象方法处理程序

用户提供的信号处理程序将按照连接它们的顺序调用。

所有处理程序都可以过早地停止信号发射，并且在信号发射期间，任何数量的处理程序都可以被连接、断开、阻塞或解除阻塞。

在信号发射的阶段2和阶段4中，有一些跳过用户处理程序的标准。

首先，用户处理程序可能被阻塞。在回调调用期间，被阻塞的处理程序被省略，为了从阻塞状态返回，处理程序必须被解封的次数与之前被阻塞的次数完全相同。

其次，在发出G_SIGNAL_DETAILED信号时，传递给g_signal_emit（）的附加细节参数必须与当前被调用的信号处理程序的细节参数相匹配。信号处理程序的无详细参数的规范（连接时省略信号规范的详细部分）用作通配符，并匹配传递给发射的任何详细参数。

虽然detail参数通常用于传递对象属性名称（如GObject::notify），但detail字符串没有强制要求特定格式，只是它必须是非空的。

## 信号处理函数的内存管理

如果您正在将处理程序连接到信号并使用GObject实例作为信号处理程序用户数据，则应该记住将对`g_signal_connect()`的调用与`g_signal_handler_disconnect()`或`g_signal_handlers_disconnect_by_func()`的调用配对。当发出信号的对象结束时，信号处理程序会自动断开，但当信号处理程序用户数据被销毁时，它们不会自动断开。如果这个用户数据是一个GObject实例，那么在它完成之后从信号处理程序中使用它是一个错误。

管理此类用户数据有两种策略。第一种是在用户数据（对象）结束时断开信号处理程序（使用`g_signal_handler_disconnect()`或`g_signal_handlers_disconnect_by_func()`）；这必须手动实现。对于非线程程序，可以使用`g_signal_connect_object()`来自动实现这一点。然而，目前在线程程序中使用它是不安全的。

第二种方法是在信号因其他原因断开之前保持对用户数据的强引用。这可以使用`g_signal_connect_data()`自动实现。

建议使用第一种方法，因为如果由于某种原因从未断开信号处理程序，则第二种方法可能导致用户数据的有效内存泄漏。
